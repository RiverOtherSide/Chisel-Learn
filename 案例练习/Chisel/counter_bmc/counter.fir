circuit counter :
  extmodule ResetCounter :
    input clk : Clock
    input reset : UInt<1>
    output timeSinceReset : UInt<32>
    output notChaos : UInt<1>
    defname = ResetCounter

  module counter :
    input clock : Clock
    input reset : UInt<1>
    output io : { count : UInt<8>}

    inst resetCounter of ResetCounter @[Formal.scala 10:36]
    resetCounter.clk <= clock @[Formal.scala 11:23]
    resetCounter.reset <= reset @[Formal.scala 12:25]
    reg count : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[counter.scala 9:22]
    node _count_T = add(count, UInt<1>("h1")) @[counter.scala 10:18]
    node _count_T_1 = tail(_count_T, 1) @[counter.scala 10:18]
    count <= _count_T_1 @[counter.scala 10:9]
    node _T = eq(count, UInt<4>("ha")) @[counter.scala 11:14]
    when _T : @[counter.scala 11:29]
      count <= UInt<1>("h0") @[counter.scala 12:11]
    io.count <= count @[counter.scala 14:12]
    node _T_1 = lt(count, UInt<4>("hb")) @[counter.scala 15:16]
    when resetCounter.notChaos : @[counter.scala 15:9]
      node _T_2 = bits(reset, 0, 0) @[counter.scala 15:9]
      node _T_3 = eq(_T_2, UInt<1>("h0")) @[counter.scala 15:9]
      when _T_3 : @[counter.scala 15:9]
        node _T_4 = eq(_T_1, UInt<1>("h0")) @[counter.scala 15:9]
        when _T_4 : @[counter.scala 15:9]
          printf(clock, UInt<1>("h1"), "Assertion failed: \n    at Formal.scala:20 cassert(cond, msg)\n") : printf @[counter.scala 15:9]
        assert(clock, _T_1, UInt<1>("h1"), "") : assert @[counter.scala 15:9]
    node _T_5 = eq(count, UInt<1>("h0")) @[counter.scala 17:23]
    node _T_6 = eq(resetCounter.timeSinceReset, UInt<1>("h0")) @[counter.scala 17:11]
    node _T_7 = and(resetCounter.notChaos, _T_6) @[counter.scala 17:11]
    when _T_7 : @[counter.scala 17:11]
      node _T_8 = bits(reset, 0, 0) @[counter.scala 17:11]
      node _T_9 = eq(_T_8, UInt<1>("h0")) @[counter.scala 17:11]
      when _T_9 : @[counter.scala 17:11]
        node _T_10 = eq(_T_5, UInt<1>("h0")) @[counter.scala 17:11]
        when _T_10 : @[counter.scala 17:11]
          printf(clock, UInt<1>("h1"), "Assertion failed: \n    at Formal.scala:28 cassert(cond, msg)\n") : printf_1 @[counter.scala 17:11]
        assert(clock, _T_5, UInt<1>("h1"), "") : assert_1 @[counter.scala 17:11]
    node _T_11 = eq(count, UInt<1>("h1")) @[counter.scala 18:23]
    node _T_12 = eq(resetCounter.timeSinceReset, UInt<1>("h1")) @[counter.scala 18:11]
    node _T_13 = and(resetCounter.notChaos, _T_12) @[counter.scala 18:11]
    when _T_13 : @[counter.scala 18:11]
      node _T_14 = bits(reset, 0, 0) @[counter.scala 18:11]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[counter.scala 18:11]
      when _T_15 : @[counter.scala 18:11]
        node _T_16 = eq(_T_11, UInt<1>("h0")) @[counter.scala 18:11]
        when _T_16 : @[counter.scala 18:11]
          printf(clock, UInt<1>("h1"), "Assertion failed: \n    at Formal.scala:28 cassert(cond, msg)\n") : printf_2 @[counter.scala 18:11]
        assert(clock, _T_11, UInt<1>("h1"), "") : assert_2 @[counter.scala 18:11]
    node _T_17 = eq(count, UInt<2>("h2")) @[counter.scala 19:23]
    node _T_18 = eq(resetCounter.timeSinceReset, UInt<2>("h2")) @[counter.scala 19:11]
    node _T_19 = and(resetCounter.notChaos, _T_18) @[counter.scala 19:11]
    when _T_19 : @[counter.scala 19:11]
      node _T_20 = bits(reset, 0, 0) @[counter.scala 19:11]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[counter.scala 19:11]
      when _T_21 : @[counter.scala 19:11]
        node _T_22 = eq(_T_17, UInt<1>("h0")) @[counter.scala 19:11]
        when _T_22 : @[counter.scala 19:11]
          printf(clock, UInt<1>("h1"), "Assertion failed: \n    at Formal.scala:28 cassert(cond, msg)\n") : printf_3 @[counter.scala 19:11]
        assert(clock, _T_17, UInt<1>("h1"), "") : assert_3 @[counter.scala 19:11]
    node _T_23 = eq(count, UInt<2>("h3")) @[counter.scala 20:23]
    node _T_24 = eq(resetCounter.timeSinceReset, UInt<2>("h3")) @[counter.scala 20:11]
    node _T_25 = and(resetCounter.notChaos, _T_24) @[counter.scala 20:11]
    when _T_25 : @[counter.scala 20:11]
      node _T_26 = bits(reset, 0, 0) @[counter.scala 20:11]
      node _T_27 = eq(_T_26, UInt<1>("h0")) @[counter.scala 20:11]
      when _T_27 : @[counter.scala 20:11]
        node _T_28 = eq(_T_23, UInt<1>("h0")) @[counter.scala 20:11]
        when _T_28 : @[counter.scala 20:11]
          printf(clock, UInt<1>("h1"), "Assertion failed: \n    at Formal.scala:28 cassert(cond, msg)\n") : printf_4 @[counter.scala 20:11]
        assert(clock, _T_23, UInt<1>("h1"), "") : assert_4 @[counter.scala 20:11]
    node _T_29 = eq(count, UInt<3>("h4")) @[counter.scala 21:23]
    node _T_30 = eq(resetCounter.timeSinceReset, UInt<3>("h4")) @[counter.scala 21:11]
    node _T_31 = and(resetCounter.notChaos, _T_30) @[counter.scala 21:11]
    when _T_31 : @[counter.scala 21:11]
      node _T_32 = bits(reset, 0, 0) @[counter.scala 21:11]
      node _T_33 = eq(_T_32, UInt<1>("h0")) @[counter.scala 21:11]
      when _T_33 : @[counter.scala 21:11]
        node _T_34 = eq(_T_29, UInt<1>("h0")) @[counter.scala 21:11]
        when _T_34 : @[counter.scala 21:11]
          printf(clock, UInt<1>("h1"), "Assertion failed: \n    at Formal.scala:28 cassert(cond, msg)\n") : printf_5 @[counter.scala 21:11]
        assert(clock, _T_29, UInt<1>("h1"), "") : assert_5 @[counter.scala 21:11]
    node _T_35 = eq(count, UInt<1>("h0")) @[counter.scala 22:35]
    node _T_36 = eq(resetCounter.timeSinceReset, UInt<4>("hb")) @[counter.scala 22:11]
    node _T_37 = and(resetCounter.notChaos, _T_36) @[counter.scala 22:11]
    when _T_37 : @[counter.scala 22:11]
      node _T_38 = bits(reset, 0, 0) @[counter.scala 22:11]
      node _T_39 = eq(_T_38, UInt<1>("h0")) @[counter.scala 22:11]
      when _T_39 : @[counter.scala 22:11]
        node _T_40 = eq(_T_35, UInt<1>("h0")) @[counter.scala 22:11]
        when _T_40 : @[counter.scala 22:11]
          printf(clock, UInt<1>("h1"), "Assertion failed: \n    at Formal.scala:28 cassert(cond, msg)\n") : printf_6 @[counter.scala 22:11]
        assert(clock, _T_35, UInt<1>("h1"), "") : assert_6 @[counter.scala 22:11]


